from datetime import datetime
from typing import Callable, Dict, List, Optional, Union
import numpy as np
from dataclasses import dataclass, field
from qube.core.utils import time_to_str, time_delta_to_str, recognize_timeframe


dt_64 = np.datetime64


@dataclass
class FuturesInfo:
    contract_type: Optional[str] = None             # contract type  
    delivery_date: Optional[datetime] = None        # delivery date
    onboard_date: Optional[datetime] = None         # futures contract size
    contract_size: float = 1.0                      # futures contract size
    maint_margin: float = 0.0                       # maintanance margin
    required_margin: float = 0.0                    # required margin
    liquidation_fee: float = 0.0                    # liquidation cost

    def __str__(self) -> str:
        return f"{self.contract_type} ({self.contract_size}) {self.onboard_date.isoformat()} -> {self.delivery_date.isoformat()}"


@dataclass
class Instrument:
    symbol: str                                     # instrument's name
    market_type: str                                # market type (CRYPTO, STOCK, FX, etc)
    exchange: str                                   # exchange id
    base: str                                       # base symbol
    quote: str                                      # quote symbol
    margin_symbol: str                              # margin asset
    min_tick: float = 0.0                           # tick size - minimal price change
    min_size_step: float = 0.0                      # minimal position change step size
    min_size: float = 0.0                           # minimal allowed position size

    # - futures section
    futures_info: Optional[FuturesInfo] = None          

    _aux_instrument: Optional['Instrument'] = None  # instrument used for conversion to main asset basis
                                                    #  | let's say we trade BTC/ETH with main account in USDT
                                                    #  | so we need to use ETH/USDT for convert profits/losses to USDT
    _tick_precision: int = field(repr=False ,default=-1) #type: check
    _size_precision: int = field(repr=False ,default=-1)

    @property
    def is_futures(self) -> bool:
        return self.futures_info is not None

    @property
    def price_precision(self):
        if self._tick_precision < 0:
            self._tick_precision = int(abs(np.log10(self.min_tick)))
        return self._tick_precision

    @property
    def size_precision(self):
        if self._size_precision < 0:
            self._size_precision = int(abs(np.log10(self.min_size_step)))
        return self._size_precision

    def __str__(self) -> str:
        return f"{self.exchange}:{self.symbol} [{self.market_type} {str(self.futures_info) if self.futures_info else 'SPOT ' + self.base + '/' + self.quote }]" 


@dataclass
class Signal: 
    """
    Class for presenting signals generated by strategy
    """
    instrument: Instrument
    signal: float
    price: Optional[float] = None
    stop: Optional[float] = None
    take: Optional[float] = None
    group: Optional[str] = None 
    comment: Optional[str] = None


class TransactionCostsCalculator:
    def __init__(self, taker: float, maker: float):
        self.taker = taker
        self.maker = maker

    def get_execution_fees(self, instrument: Instrument, exec_price: float, amount: float, crossed_market=False, conversion_rate=1.0):
        if not instrument.is_futures:
            amount = amount * exec_price

        if crossed_market:
            return conversion_rate * abs(amount) * self.taker
        else:
            return conversion_rate * abs(amount) * self.maker

    def get_overnight_fees(self, instrument: Instrument, amount: float):
        return 0.0

    def get_funding_rates_fees(self, instrument: Instrument, amount: float):
        return 0.0

    def __repr__(self):
        return f'<TCC: {self.maker * 100:.4f} / {self.taker * 100:.4f}>'

ZERO_COSTS = TransactionCostsCalculator(0.0, 0.0)


class Position:
    instrument: Instrument                      # instrument for this poisition
    quantity: float = 0.0                       # quantity positive for long and negative for short
    tcc: TransactionCostsCalculator             # transaction costs calculator
    pnl: float = 0.0                            # total cumulative position PnL in portfolio funds currency
    r_pnl: float = 0.0                          # total cumulative position PnL in portfolio funds currency
    market_value: float = 0.0                   # position's market value in quote currency
    market_value_funds: float = 0.0             # position market value in portfolio funded currency
    cost_quoted: float = 0.0                    # position's cost in quote currency
    cost_funds: float = 0.0                     # position cost in basic currency
    commissions: float = 0.0                    # cumulative commissions paid for this position

    last_update_time: Optional[dt_64] = None    # when price updated or position changed
    last_update_price: Optional[float] = None   # last update price (actually instrument's price) in quoted currency

    def __init__(self, instrument: Instrument, tcc: TransactionCostsCalculator, 
                 quantity=0.0, average_price=0.0, aux_price=1.0, 
                 ) -> None:
        self.instrument = instrument
        self.tcc = tcc

        if quantity != 0.0 and average_price > 0.0:
            self.quantity = quantity
            raise ValueError("[TODO] Position: restore state by quantity and avg price !!!!")

    def __str__(self):
        _t_str = ''
        if self.last_update_time:
            _t_str = time_to_str(self.last_update_time, 'ns')
            _t_str = str(self.last_update_time)
        _p_str = "???" if self.last_update_price is None else ('%.5f' % self.last_update_price)
        _c_str = "$%.2f" % self.cost_funds
        return '[%s]  %s   %.0f   %s   %.2f  $%.2f / %s' % (
            self.instrument.symbol, _t_str, self.quantity, _p_str, self.pnl, self.market_value, _c_str)
    
